*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sfregistry.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sfregistry AS custom 		&& A class that works with the Windows Registry
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfregistry.h"
	*<DefinedPropArrayMethod>
		*m: closekey		&& Close the current registry key
		*m: deletekey		&& Delete the specified key
		*m: deletekeyvalue		&& Deletes a value under a key
		*m: enumeratekeys		&& Enumerate key names from the specfied key
		*m: enumeratekeyvalues		&& Enumerate values under the specified key
		*m: getkey		&& Gets the value for the specified key
		*m: iskey		&& Returns .T. if the specified key exists
		*m: iskeyvalue		&& Returns .T. if the specified key value exists
		*m: moveregistrykeys		&& Moves all keys and values from one location to another
		*m: openkey		&& Opens the specified key
		*m: setkey		&& Sets the specified key to the specified value
		*p: ncurrentkey		&& The current open key
		*p: nmainkey		&& The main key for the Registry
		*p: nresult		&& The result code of the most recent method call
	*</DefinedPropArrayMethod>

	PROTECTED ncurrentkey
	Name = "sfregistry"
	ncurrentkey = 0		&& The current open key
	nmainkey = 0		&& The main key for the Registry
	nresult = 0		&& The result code of the most recent method call
	Width = 17
	
	PROTECTED PROCEDURE closekey		&& Close the current registry key
		* Close the current key and blank the current key value.
		
		with This
			RegCloseKey(.nCurrentKey)
			.nCurrentKey = 0 
		endwith
		
	ENDPROC

	PROCEDURE deletekey		&& Delete the specified key
		* Delete the specified key and all subkeys and values under it.
		
		lparameters tcSubKey, ;
			tnMainKey
		local laKeys[1], ;
			lnKeys, ;
			llReturn, ;
			lnI, ;
			lcKey, ;
			lnMainKey, ;
			lcSubKey
		with This
		
		* Call ourselves recursively to delete all subkeys first.
		
			lnKeys   = .EnumerateKeys(tcSubKey, @laKeys, tnMainKey)
			llReturn = .T.
			for lnI = 1 to lnKeys
				lcKey    = addbs(tcSubKey) + laKeys[lnI]
				llReturn = .DeleteKey(lcKey, tnMainKey)
				if not llReturn
					exit
				endif not llReturn
			next lnI
			if llReturn
		
		* If the main key wasn't passed, use the default value.
		
				lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, ;
					.nMainKey, tnMainKey)
		
		* Strip any trailing backslash off the subkey (Windows NT accepts a trailing
		* backslash but Windows 95/98 do not).
		
				lcSubKey = iif(right(tcSubKey, 1) = '\', ;
					left(tcSubKey, len(tcSubKey) - 1), tcSubKey)
		
		* Delete the key and return .T. if it succeeded.
		
				.nResult = RegDeleteKey(lnMainKey, lcSubKey)
				llReturn = .nResult = cnSUCCESS
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE deletekeyvalue		&& Deletes a value under a key
		* Delete the specified value in the specified key.
		
		lparameters tcSubKey, ;
			tcValue, ;
			tnMainKey
		local lnMainKey, ;
			llReturn
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* Try to open the registry key. If we couldn't, return .F.
		
			if .OpenKey(tcSubKey, lnMainKey)
		
		* Delete the key and return .T. if it succeeded.
		
				.nResult = RegDeleteValue(.nCurrentKey, tcValue)
				llReturn = .nResult = cnSUCCESS
		
		* Close the registry key and return the value.
		
				.CloseKey()
			endif .OpenKey(tcSubKey, lnMainKey)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE enumeratekeys		&& Enumerate key names from the specfied key
		lparameters tcSubKey, ;
			taKeyNames, ;
			tnMainKey
		local lnMainKey, ;
			lnNames, ;
			lcKey, ;
			lnSize, ;
			lcBuffer1, ;
			lnSize1, ;
			lcBuffer2
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* Try to open the registry key.
		
			if .OpenKey(tcSubKey, lnMainKey)
		
		* Initialize the number of names and the result code.
		
				lnNames  = 0
				.nResult = cnSUCCESS
		
		* As long as everything is OK, keep getting key names.
		
				do while .nResult = cnSUCCESS
		
		* Create buffers to hold return values from the Registry function.
		
					lcKey     = space(cnBUFFER_SIZE)
					lnSize    = cnBUFFER_SIZE
					lcBuffer1 = space(cnBUFFER_SIZE)
					lnSize1   = cnBUFFER_SIZE
					lcBuffer2 = space(cnBUFFER_SIZE)
		
		* Get the next key name from the Registry.
		
					.nResult = RegEnumKeyEx(.nCurrentKey, lnNames, @lcKey, @lnSize, ;
						cnRESERVED, @lcBuffer1, @lnSize1, @lcBuffer2)
					do case
		
		* If we got a name, add it to the array.
		
						case .nResult = cnSUCCESS
							lcKey   = alltrim(lcKey)
							lcKey   = left(lcKey, len(lcKey) - 1)
							lnNames = lnNames + 1
							dimension taKeyNames[lnNames]
							taKeyNames[lnNames] = lcKey
		
		* If we had an error and it's not EOF, return an error code.
		
						case .nResult <> cnERROR_EOF
							lnNames = 0
					endcase
				enddo while .nResult = cnSUCCESS
		
		* Close the registry key.
		
				.CloseKey()
		
		* We couldn't open the key, so return 0 entries.
		
			else
				lnNames = 0
			endif .OpenKey(tcSubKey, lnMainKey)
		endwith
		return lnNames
		
	ENDPROC

	PROCEDURE enumeratekeyvalues		&& Enumerate values under the specified key
		lparameters tcSubKey, ;
			taKeyValues, ;
			tnMainKey
		local lnMainKey, ;
			lnValues, ;
			lcKey, ;
			lnKeySize, ;
			lcValue, ;
			lnValSize, ;
			lnType, ;
			lcBuffer, ;
			lnSize
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* Try to open the registry key.
		
			if .OpenKey(tcSubKey, lnMainKey)
		
		* Initialize the number of names and the result code.
		
				lnValues = 0
				.nResult = cnSUCCESS
		
		* As long as everything is OK, keep getting key names.
		
				do while .nResult = cnSUCCESS
		
		* Create buffers to hold return values from the Registry function.
		
					lcKey     = space(cnBUFFER_SIZE)
					lnKeySize = cnBUFFER_SIZE
					lcValue   = space(cnBUFFER_SIZE)
					lnValSize = cnBUFFER_SIZE
					lnType    = 0
		
		* Get the next key name from the Registry.
		
					.nResult = RegEnumValue(.nCurrentKey, lnValues, @lcKey, ;
						@lnKeySize, cnRESERVED, @lnType, @lcValue, @lnValSize)
					do case
		
		* If we got a name, add it to the array.
		
						case .nResult = cnSUCCESS
							lcKey    = left(lcKey, lnKeySize)
							lnValues = lnValues + 1
							dimension taKeyValues[lnValues, 2]
							taKeyValues[lnValues, 1] = lcKey
							do case
								case lnType = cnREG_SZ
									taKeyValues[lnValues, 2] = left(lcValue, ;
										lnValSize - 1)
								case lnType = cnREG_DWORD
									taKeyValues[lnValues, 2] = ctobin(left(lcValue, 4), ;
										'4RS')
								case lnType = cnREG_EXPAND_SZ
									lcValue  = left(lcValue, lnValSize - 1)
									lcBuffer = space(cnBUFFER_SIZE)
									lnSize   = cnBUFFER_SIZE
									lnSize   = ExpandEnvironmentStrings(@lcValue, ;
										@lcBuffer, lnSize)
									taKeyValues[lnValues, 2] = left(lcBuffer, ;
										lnSize - 1)
								case lnType = cnREG_BINARY
									taKeyValues[lnValues, 2] = left(lcValue, lnValSize)
								case lnType = cnREG_MULTI_SZ
									taKeyValues[lnValues, 2] = strtran(left(lcValue, ;
										lnValSize - 1), ccNULL, ccCR)
										&& use ALINES() on the return value to get the individual
										&& values
							endcase
		
		* If we had an error and it's not EOF, return 0 entries.
		
						case .nResult <> cnERROR_EOF
							lnValues = 0
					endcase
				enddo while .nResult = cnSUCCESS
		
		* Close the registry key.
		
				.CloseKey()
		
		* We couldn't open the key, so return 0 entries.
		
			else
				lnValues = 0
			endif .OpenKey(tcSubKey, lnMainKey)
		endwith
		return lnValues
		
	ENDPROC

	PROCEDURE getkey		&& Gets the value for the specified key
		lparameters tcSubKey, ;
			tcValueName, ;
			tuDefault, ;
			tnMainKey, ;
			tl64Bit
		local lnMainKey, ;
			luValue, ;
			lcValueName, ;
			lcBuffer, ;
			lnSize, ;
			lnType, ;
			lnFlags
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* If the default to use wasn't passed, initialize it to an empty string.
		
			luValue = iif(vartype(tuDefault) = 'C', tuDefault, '')
		
		* If the value name wasn't specified, initialize it to an empty string, meaning
		* the default value.
		
			lcValueName = iif(vartype(tcValueName) = 'C', tcValueName, '')
		
		* Create a buffer to hold the key value.
		
			lcBuffer = space(cnBUFFER_SIZE)
			lnSize   = cnBUFFER_SIZE
			lnType   = 0
		
		* If we're supposed to get a 64-bit value, do so.
		
			do case
				case tl64Bit
					lnFlags  = cnRRF_RT_ANY + cnRRF_SUBKEY_WOW6464KEY
					.nResult = RegGetValue(.nCurrentKey, tcSubKey, lcValueName, ;
						lnFlags, @lnType, @lcBuffer, @lnSize)
		
		* Get a 32-bit value.
		
				case .OpenKey(tcSubKey, lnMainKey)
					.nResult = RegQueryValueEx(.nCurrentKey, lcValueName, cnRESERVED, ;
						@lnType, @lcBuffer, @lnSize)
					.CloseKey()
			endcase
		
		* Get the key value and convert it into the proper return value based on the
		* data type.
		
			do case
				case .nResult <> cnSUCCESS
				case lnType = cnREG_SZ
					luValue = left(lcBuffer, lnSize - 1)
				case lnType = cnREG_EXPAND_SZ
					luValue  = left(lcBuffer, lnSize - 1)
					lcBuffer = space(cnBUFFER_SIZE)
					lnSize   = cnBUFFER_SIZE
					lnSize   = ExpandEnvironmentStrings(@luValue, @lcBuffer, ;
						lnSize)
					luValue  = left(lcBuffer, lnSize - 1)
				case lnType = cnREG_DWORD
					luValue = ctobin(left(lcBuffer, 4), '4RS')
				case lnType = cnREG_BINARY
					luValue = left(lcBuffer, lnSize)
				case lnType = cnREG_MULTI_SZ
					luValue = strtran(left(lcBuffer, lnSize - 1), ccNULL, ccCR)
						&& use ALINES() on the return value to get the individual
						&& values
			endcase
		endwith
		return luValue
		
	ENDPROC

	PROCEDURE Init
		lparameters tnMainKey
		
		* Declare the API functions we'll need.
		
		declare integer RegOpenKey in Win32API ;
			integer nKey, string @cSubKey, integer @nHandle
		declare integer RegCreateKey in Win32API ;
			integer nKey, string @cSubKey, integer @nHandle
		declare integer RegDeleteKey in Win32API ;
			integer nKey, string @cSubKey
		declare integer RegCloseKey in Win32API ;
			integer nKey
		declare integer RegSetValueEx in Win32API ;
			integer nKey, string cValueName, integer nReserved, ;
			integer nType, string cBuffer, integer nBufferSize
		declare integer RegQueryValueEx in Win32API ;
			integer nKey, string cValueName, integer nReserved, ;
			integer @nType, string @cBuffer, integer @nBufferSize
		declare integer RegDeleteValue in Win32API ;
			integer nKey, string cSubKey
		declare integer RegEnumKey in Win32API ;
			integer nKey, integer nSubKey, string @cSubKey, integer @nKeySize
		declare integer RegEnumKeyEx in Win32API ;
			integer nKey, integer nSubKey, string @cSubKey, integer @nKeySize,;
			integer nReserved, string @cBuffer, integer @nBufferSize, string @cBuffer
		declare integer RegEnumValue IN Win32API ;
			integer nKey, integer nValue, string @cSubKey, ;
			integer @nKeySize, integer nReserved, integer @nType, ;
			string @cValue, integer @nValSize
		declare integer ExpandEnvironmentStrings IN Win32API ;
			string @lpSrc, string @lpDst, integer nSize
		declare integer RegGetValue IN Win32API ;
			integer hkey, string lpSubKey, string lpValue, integer dwFlags, ;
			integer @pdwType, string @pvData, integer @pcbData
		
		* Initialize the main key.
		
		This.nMainKey = iif(vartype(tnMainKey) = 'N', tnMainKey, cnHKEY_CURRENT_USER)
		
		* Carry on with the base behavior.
		
		dodefault()
		
	ENDPROC

	PROCEDURE iskey		&& Returns .T. if the specified key exists
		lparameters tcSubKey, ;
			tnMainKey
		local lnMainKey, ;
			llReturn
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* Try to open the registry key. If we could, the key exists, so close it.
		
			llReturn = .OpenKey(tcSubKey, lnMainKey)
			if llReturn
				.CloseKey()
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE iskeyvalue		&& Returns .T. if the specified key value exists
		lparameters tcSubKey, ;
			tcValueName, ;
			tnMainKey
		This.GetKey(tcSubKey, tcValueName, , tnMainKey)
		return This.nResult = cnSUCCESS
		
	ENDPROC

	PROCEDURE moveregistrykeys		&& Moves all keys and values from one location to another
		lparameters tcOldKey, ;
			tcNewKey, ;
			tlNoDelete
		local laKeys[1], ;
			lnKeys, ;
			lnI, ;
			lcKey, ;
			lcOldKey, ;
			lcNewKey, ;
			laValues[1], ;
			lnValues
		with This
		
		* Get all subkeys and call ourselves recursively to get all subkeys of those
		* and copy them to the new location (and possibly remove them from the old
		* location).
		
			lnKeys = .EnumerateKeys(tcOldKey, @laKeys)
			for lnI = 1 to lnKeys
				lcKey    = laKeys[lnI]
				lcOldKey = addbs(tcOldKey) + lcKey
				lcNewKey = addbs(tcNewKey) + lcKey
				.MoveRegistryKeys(lcOldKey, lcNewKey, tlNoDelete)
			next lnI
		
		* Get all values copy them to the new location (and possibly remove them from
		* the old location).
		
			lnValues = .EnumerateKeyValues(tcOldKey, @laValues)
			for lnI = 1 to lnValues
				.SetKey(tcNewKey, laValues[lnI, 1], laValues[lnI, 2])
			next lnI
			if not tlNoDelete
				.DeleteKey(tcOldKey)
			endif not tlNoDelete
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE openkey		&& Opens the specified key
		lparameters tcSubKey, ;
			tnMainKey, ;
			tlCreate
		local lnHandle, ;
			lcSubKey, ;
			llReturn
		
		* Try to create or open the registry key. If it succeeded, store the key handle
		* in the nCurrentKey property; if not, zero nCurrentKey.
		
		with This
			lnHandle = 0
		
		* Strip any trailing backslash off the subkey (Windows NT accepts a trailing
		* backslash but Windows 95/98 do not).
		
			lcSubKey = iif(right(tcSubKey, 1) = '\', ;
				left(tcSubKey, len(tcSubKey) - 1), tcSubKey)
			if tlCreate
				.nResult = RegCreateKey(tnMainKey, lcSubKey, @lnHandle)
			else
				.nResult = RegOpenKey(tnMainKey, lcSubKey, @lnHandle)
			endif tlCreate
			llReturn     = .nResult = cnSUCCESS
			.nCurrentKey = iif(llReturn, lnHandle, 0)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE setkey		&& Sets the specified key to the specified value
		lparameters tcSubKey, ;
			tcValueName, ;
			tuValue, ;
			tnMainKey, ;
			tnType
		local lnMainKey, ;
			lcDataType, ;
			lcValue, ;
			lnSize, ;
			lcValueName, ;
			llReturn
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* If the type wasn't specified, initialize it to cnREG_SZ.
		
			lnType = iif(vartype(tnType) = 'N', tnType, cnREG_SZ)
		
		* Convert the value to a string if necessary. Terminate the string with a null
		* and calculate the size.
		
			lcDataType = vartype(tuValue)
			do case
				case lnType = cnREG_MULTI_SZ
					lcValue = strtran(tuValue, ccCR, ccNULL)
				case lcDataType = 'C'
					lcValue = tuValue
				case lcDataType $ 'NIFYB' and lnType = cnREG_DWORD
					lcValue = bintoc(tuValue, '4RS')
				case lcDataType $ 'NIFYB'
					lcValue = transform(tuValue)
				case lcDataType = 'D'
					lcValue = dtoc(tuValue)
				case lcDataType = 'T'
					lcValue = ttoc(tuValue)
				case lcDataType = 'L'
					lcValue = iif(tuValue, 'Y', 'N')
			endcase
			if inlist(lnType, cnREG_SZ, cnREG_EXPAND_SZ)
				lcValue = lcValue + ccNULL
			endif inlist(lnType, cnREG_SZ, cnREG_EXPAND_SZ)
			lnSize = len(lcValue)
		
		* If the value name wasn't specified, initialize it to an empty string, meaning
		* the default value.
		
			lcValueName = iif(vartype(tcValueName) = 'C', tcValueName, '')
		
		* Try to open or create the registry key. If we couldn't, return .F.
		
			if .OpenKey(tcSubKey, lnMainKey, .T.)
		
		* Set the key value.
		
				.nResult = RegSetValueEx(.nCurrentKey, lcValueName, cnRESERVED, ;
					lnType, lcValue, lnSize)
				llReturn = .nResult = cnSUCCESS
		
		* Close the registry key and return the success flag.
		
				.CloseKey()
			endif .OpenKey(tcSubKey, lnMainKey, .T.)
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfregistryodbc AS sfregistry OF "sfregistry.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfregistry.h"
	*<DefinedPropArrayMethod>
		*m: createuserdsn		&& Creates a user DSN
		*m: dsnexists		&& Returns .T. if the specified user DSN exists
		*m: getdatasourceproperty		&& Gets a property of the specified datasource
		*m: getdatasources		&& Populates the passed array with data sources
		*m: getdrivers		&& Populates the passed array with ODBC drivers
		*m: getforeignkeys		&& Gets the foreign keys for the specified table
		*m: getodbcinformation		&& Gets the specified ODBC information
		*m: handleodbcerror		&& Handles an ODBC error
		*m: isdriverinstalled		&& Determines if the specified driver is installed
		*m: removeuserdsn		&& Removes the specified user DSN
		*m: sqlconnect		&& Connects to the specified DSN
		*m: sqldisconnect		&& Disconnects from the DSN
		*p: nconn		&& The connection handle
		*p: nenv		&& The environment handle
		*a: aerrorinfo[1,0]		&& An array of errors that may have occurred
	*</DefinedPropArrayMethod>

	Name = "sfregistryodbc"
	nconn = 0		&& The connection handle
	nenv = 0		&& The environment handle
	_memberdata = <VFPData>
		<memberdata name="createuserdsn" type="method" display="CreateUserDSN"/>
		<memberdata name="dsnexists" type="method" display="DSNExists"/>
		<memberdata name="getdatasourceproperty" type="method" display="GetDataSourceProperty"/>
		<memberdata name="getdatasources" type="method" display="GetDataSources"/>
		<memberdata name="getdrivers" type="method" display="GetDrivers"/>
		<memberdata name="getodbcinformation" type="method" display="GetODBCInformation"/>
		<memberdata name="handleodbcerror" type="method" display="HandleODBCError"/>
		<memberdata name="isdriverinstalled" type="method" display="IsDriverInstalled"/>
		<memberdata name="removeuserdsn" type="method" display="RemoveUserDSN"/>
		<memberdata name="getforeignkeys" display="GetForeignKeys"/>
		<memberdata name="sqlconnect" display="SQLConnect"/>
		<memberdata name="sqldisconnect" display="SQLDisconnect"/>
		<memberdata name="nenv" display="nEnv"/>
		<memberdata name="nconn" display="nConn"/>
		</VFPData>
	
	PROCEDURE createuserdsn		&& Creates a user DSN
		lparameter tcDriverName, ;
			tcDSN, ;
			tcSettingString
		local lcSettingString, ;
			llModify, ;
			lnSuccess, ;
			llReturn
		if vartype(tcDriverName) = 'C' and not empty(tcDriverName) and ;
			vartype(tcDSN) = 'C' and not empty(tcDSN) and ;
			vartype(tcSettingString) = 'C' and not empty(tcSettingString)
			lcSettingString = tcSettingString
			if right(lcSettingString, 1) <> ccNULL
				lcSettingString = lcSettingString + ccNULL
			endif right(lcSettingString, 1) <> ccNULL
			if not 'DSN=' $ upper(lcSettingString)
				lcSettingString = 'DSN=' + tcDSN + ccNULL + lcSettingString
			endif not 'DSN=' $ upper(lcSettingString)
			llModify  = This.DSNExists(tcDSN)
			lnSuccess = SQLConfigDataSource(0, ;
				iif(llModify, cnODBC_CONFIG_DSN, cnODBC_ADD_DSN), tcDriverName, ;
				lcSettingString)
			llReturn = lnSuccess > 0
			if not llReturn
				This.HandleODBCError()
			endif not llReturn
		endif vartype(tcDriverName) = 'C' ...
		return llReturn
		
	ENDPROC

	PROCEDURE dsnexists		&& Returns .T. if the specified user DSN exists
		* See if the specified DSN exists as a user DSN. If not, see if it exists as a
		* system DSN.
		
		lparameters tcDSN
		local llReturn
		if vartype(tcDSN) = 'C' and not empty(tcDSN)
			llReturn = This.IsKey(ccODBC_DATA_KEY + tcDSN)
			if not llReturn
				llReturn = This.IsKey(ccODBC_DATA_KEY + tcDSN, cnHKEY_LOCAL_MACHINE)
			endif not llReturn
		endif vartype(tcDSN) = 'C' ...
		return llReturn
		
	ENDPROC

	PROCEDURE getdatasourceproperty		&& Gets a property of the specified datasource
		lparameters tcDataSource, ;
			tcValueName
		local lcValue
		lcValue = This.GetKey(ccODBC_DATA_KEY + tcDataSource, tcValueName, '')
		if empty(lcValue)
			lcValue = This.GetKey(ccODBC_DATA_KEY + tcDataSource, tcValueName, '', ;
				cnHKEY_LOCAL_MACHINE)
		endif empty(lcValue)
		return lcValue
		
	ENDPROC

	PROCEDURE getdatasources		&& Populates the passed array with data sources
		lparameters taArray
		return This.GetODBCInformation(@taArray, .T.)
		
	ENDPROC

	PROCEDURE getdrivers		&& Populates the passed array with ODBC drivers
		lparameters taArray
		return This.GetODBCInformation(@taArray)
		
	ENDPROC

	PROCEDURE getforeignkeys		&& Gets the foreign keys for the specified table
		*==============================================================================
		* Method:			GetForeignKeys
		* Status:			Public
		* Purpose:			Gets the foreign keys for the specified table
		* Author:			Doug Hennig
		* Copyright:		(c) 2016 Stonefield Software Inc.
		* Last Revision:	03/29/2016
		* Parameters:		tnHandle - the connection handle to the database
		*					tcTable  - the table to get foreign keys for
		*					tcSchema - the schema for the table
		*					tcCursor - the name of the cursor to create containing the
		*						foreign keys
		* Returns:			the number of rows in the cursor if it succeeded or 0 if
		*						not
		* Environment in:	This.SQLConnect was used to connect to the DSN
		* Environment out:	none
		* Remarks:			With help from http://www.news2news.com/vfp/?example=409&function=645
		*					See https://msdn.microsoft.com/en-us/library/ms709315(v=vs.85).aspx#
		*==============================================================================
		
		lparameters tnHandle, ;
			tcTable, ;
			tcSchema, ;
			tcCursor
		local lnHandle, ;
			lnStatement, ;
			laColumns[1], ;
			lnI, ;
			lnReturn, ;
			lnRows, ;
			llDone, ;
			lcBuffer, ;
			lnLen
		
		* Get a statement handle from the connection handle. We do this instead of using
		* sqlgetprop(handle, 'ODBChstmt') because SQLForeignKeys fails when called more
		* than once in that case.
		
		lnHandle    = sqlgetprop(tnHandle, 'ODBChdbc')
		lnStatement = 0
		SQLAllocHandle(cnSQL_HANDLE_STMT, lnHandle, @lnStatement)
		if lnStatement = 0
			This.cErrorMessage = 'Cannot get statement handle'
			return 0
		endif lnStatement = 0
		
		* Allocate memory for the SQLFetch statement.
		
		dimension laColumns[5, 3]
		for lnI = 1 to 5
		    laColumns[lnI, 1] = GlobalAlloc(0, cnSTR_LEN)
		    laColumns[lnI, 2] = GlobalAlloc(0, 4)
		next lnI
		
		* Create the cursor.
		
		create cursor (tcCursor) (PARENT C(128), PARENTCOL C(128), CHILDCOL C(128), KEY_SEQ I)
		
		* Set up the binding for SQLFetch.
		
		SQLBindCol(lnStatement, 3, cnSQL_CHAR, laColumns[1, 1], cnSTR_LEN, ;
			laColumns[1, 2])	&& PK table
		SQLBindCol(lnStatement, 4, cnSQL_CHAR, laColumns[2, 1], cnSTR_LEN, ;
			laColumns[2, 2])	&& PK column
		SQLBindCol(lnStatement, 7, cnSQL_CHAR, laColumns[3, 1], cnSTR_LEN, ;
			laColumns[3, 2])	&& FK table
		SQLBindCol(lnStatement, 8, cnSQL_CHAR, laColumns[4, 1], cnSTR_LEN, ;
			laColumns[4, 2])	&& FK column
		SQLBindCol(lnStatement, 9, cnSQL_CHAR, laColumns[5, 1], cnSTR_LEN, ;
			laColumns[5, 2])	&& KEY_SEQ column
		
		* Get the foreign keys for the specified table.
		
		if empty(tcSchema)
			lnReturn = SQLForeignKeys(lnStatement, NULL, 0, NULL, 0, ;
				NULL, 0, NULL, 0, NULL, 0, tcTable, len(tcTable))
		else
			lnReturn = SQLForeignKeys(lnStatement, NULL, 0, NULL, 0, ;
				NULL, 0, NULL, 0, tcSchema, len(tcSchema), tcTable, len(tcTable))
		endif empty(tcSchema)
		lnRows = 0
		do case
			case lnReturn = cnSQL_NO_DATA
			case lnReturn <> cnSUCCESS and lnReturn <> cnSQL_SUCCESS_WITH_INFO
				This.cErrorMessage = 'error'
				This.HandleODBCError()
			otherwise
				llDone = .F.
				do while not llDone
					lnReturn = SQLFetch(lnStatement)
					do case
						case lnReturn = cnSQL_NO_DATA
							llDone = .T.
						case lnReturn <> cnSUCCESS and lnReturn <> cnSQL_SUCCESS_WITH_INFO
							llDone = .T.
							lnRows = 0
							This.cErrorMessage = 'error'
							This.HandleODBCError()
						otherwise
							for lnI = 1 to 5
								lcBuffer = replicate(ccNULL, 4)
								CopyMemory(@lcBuffer, laColumns[lnI, 2], 4)
								lnLen = ctobin(lcBuffer, '4RS')
								if between(lnLen, 1, cnSTR_LEN)
									lcBuffer = replicate(ccNULL, lnLen)
									CopyMemory(@lcBuffer, laColumns[lnI, 1], lnLen)
								else
									lcBuffer = ''
								endif between(lnLen, 1, cnSTR_LEN)
								laColumns[lnI, 3] = lcBuffer
							next lnI
							lnRows = lnRows + 1
							insert into (tcCursor) values (laColumns[1, 3], ;
								laColumns[2, 3], laColumns[4, 3], val(laColumns[5, 3]))
					endcase
				enddo while llReturn
		endcase
		
		* Release allocated memory.
		
		for lnI = 1 to 5
			GlobalFree(laColumns[lnI, 2])
			GlobalFree(laColumns[lnI, 1])
		next lnI
		SQLFreeHandle(cnSQL_HANDLE_STMT, lnStatement)
		return lnRows
		
	ENDPROC

	PROTECTED PROCEDURE getodbcinformation		&& Gets the specified ODBC information
		lparameters taArray, ;
			tlDataSources
		local lnRows, ;
			lnODBCEnv, ;
			llReturn, ;
			lcDSN, ;
			lcDSNDesc, ;
			lnDSN, ;
			lnDesc, ;
			lnReturn, ;
			lcDescrip
		
		* Initialize the variables we'll need.
		
		dimension taArray[1, iif(tlDataSources, 3, 1)]
		taArray = ''
		lnRows  = 0
		
		* Get the ODBC environment handle.
		
		lnODBCEnv = val(sys(3053))
		llReturn  = not inlist(lnODBCEnv, 527, 528, 182)
		
		* Until we run out of them, get the next data source or driver and add it to
		* the array.
		
		do while llReturn
			lcDSN     = space(100)
			lcDSNDesc = space(100)
			lnDSN     = 0
			lnDesc    = 0
			if tlDataSources
				lnReturn = SQLDataSources(lnODBCEnv, cnSQL_FETCH_NEXT, @lcDSN, 100, ;
					@lnDSN, @lcDSNDesc, 255, @lnDesc)
			else
				lnReturn = SQLDrivers(lnODBCEnv, cnSQL_FETCH_NEXT, @lcDSN, 100, ;
					@lnDSN, @lcDSNDesc, 100, @lnDesc)
			endif tlDataSources
			do case
				case lnReturn = cnSQL_NO_DATA
					llReturn = .F.
				case lnReturn <> cnSUCCESS and lnReturn <> cnSQL_SUCCESS_WITH_INFO
					llReturn = .F.
					This.HandleODBCError()
				otherwise
					lcDSN  = alltrim(lcDSN)
					lnRows = lnRows + 1
					dimension taArray[lnRows, iif(tlDataSources, 3, 1)]
					taArray[lnRows, 1] = left(lcDSN, len(lcDSN) - 1)
		
		* If we were asked for data sources, add the driver and description (which we
		* have to get from the Registry) to the array.
		
					if tlDataSources
						lcDSNDesc = alltrim(lcDSNDesc)
						taArray[lnRows, 2] = left(lcDSNDesc, len(lcDSNDesc) - 1)
						lcDescrip = This.GetKey(ccODBC_DATA_KEY + taArray[lnRows, 1], ;
							'Description', '')
						if empty(lcDescrip)
							lcDescrip = This.GetKey(ccODBC_DATA_KEY + ;
								taArray[lnRows, 1], 'Description', '', ;
								cnHKEY_LOCAL_MACHINE)
						endif empty(lcDescrip)
						taArray[lnRows, 3] = lcDescrip
					endif tlDataSources
			endcase
		enddo while llReturn
		asort(taArray, 1, -1, 0, 1)
		return lnRows
		
	ENDPROC

	PROTECTED PROCEDURE handleodbcerror		&& Handles an ODBC error
		local lnErrorIndex, ;
			lnErrorNumber, ;
			lcErrorText, ;
			lnTextSize, ;
			lnReturnSize, ;
			lnResult
		
		* Since there can be up to 8 error messages for one error, prepare to get them
		* all.
		
		lnErrorIndex = 1
		do while lnErrorIndex < 9
		
		* Initialize the variables used by the error function.
		
			lnErrorNumber = 0
			lcErrorText   = space(500)
			lnTextSize    = 0
			lnReturnSize  = 0
		
		* Get the error information for the current error index. If there aren't
		* any more error messages, we're done.
		
			lnResult = SQLInstallerError(lnErrorIndex, @lnErrorNumber, @lcErrorText, ;
				lnTextSize, @lnReturnSize)
			if lnResult = cnSQL_NO_DATA
				exit
			endif lnResult = cnSQL_NO_DATA
		
		* If a return size was specified, get the error information again.
		
			if lnReturnSize > 0
				lnTextSize  = lnReturnSize + 1
				lcErrorText = space(lnTextSize)
				lnResult    = SQLInstallerError(lnErrorIndex, @lnErrorNumber, ;
					@lcErrorText, lnTextSize, @lnReturnSize)
			endif lnReturnSize > 0
			if lnResult = cnSQL_NO_DATA
				exit
			endif lnResult = cnSQL_NO_DATA
		
		* Put the error message into aErrorInfo.
		
			if lcErrorText <> ccNULL and not empty(lcErrorText)
				lcErrorText = left(lcErrorText, at(ccNULL, lcErrorText) - 1)
				dimension This.aErrorInfo[lnErrorIndex]
				This.aErrorInfo[lnErrorIndex] = lcErrorText
			else
				This.aErrorInfo[lnErrorIndex] = ''
			endif lcErrorText <> ccNULL and not empty(lcErrorText)
			lnErrorIndex = lnErrorIndex + 1
		enddo while lnErrorIndex < 9
		return
		
	ENDPROC

	PROCEDURE Init
		lparameters tnMainKey
		
		* Load the ODBC and Win32API functions.
		
		declare short SQLDrivers in ODBC32.DLL ;
			integer hEnv, integer fDirection, ;
			string @ szDriverDesc, integer cbDriverDescMax, integer pcbDriverDesc, ;
			string @ szDriverAttributes, integer cbDrvrAttrMax, integer pcbDrvrAttr
		declare short SQLDataSources in ODBC32.DLL ;
			integer hEnv, integer fDirection, ;
			string @ szDSN, integer cbDSNMax, integer @ pcbDSN, ;
			string @ szDescription, integer cbDescriptionMax, integer pcbDescription
		declare integer SQLConfigDataSource in ODBCCP32.DLL ;
		   integer, integer, string, string
		declare integer SQLInstallerError in ODBCCP32.DLL ;
			integer, integer @, string @, integer, integer @
		declare integer GlobalFree in kernel32 integer hMem
		declare integer GlobalAlloc in kernel32 integer wFlags, integer dwBytes
		declare RtlMoveMemory in kernel32 as CopyMemory;
		    string @Dst, integer Src, integer nLen
		declare integer SQLBindCol in ODBC32.DLL ;
			integer StatementHandle, ;
			short ColumnNumber, ;
			short TargetType, ;
		    integer TargetValuePtr, ;
			integer BufferLength, ;
			integer StrLen_or_Ind
		declare short SQLFetch in ODBC32.DLL ;
			integer StatementHandle
		declare short SQLForeignKeys in ODBC32.DLL ;
			integer StatementHandle, ;
			string PKCatalogName, integer NameLength1, ;
			string PKSchemaName, integer NameLength2, ;
			string PKTableName, integer NameLength3, ;
			string FKCatalogName, integer NameLength4, ;
			string FKSchemaName, integer NameLength5, ;
			string FKTableName, integer NameLength6
		declare short SQLTables in odbc32 as SQLTables32 ;
			integer StatementHandle, ;
			string CatalogName, short NameLen1, ;
			string SchemaName, short NameLen2, ;
			string TableName, short NameLen3, ;
			string TableType, short NameLen4
		declare short SQLAllocHandle in odbc32 ;
			integer HandleType, integer InputHandle, ;
			integer @OutputHandlePtr
		declare short SQLFreeHandle in odbc32 integer HandleType, integer Handle
		declare short SQLConnect in odbc32 as SQLConn32 ;
			integer ConnHandle, string SrvName, integer NameLen1, ;
			string UserName, integer NameLen2, ;
			string Authent, integer NameLen3
		declare short SQLDisconnect in odbc32 as SQLDisc32 integer ConnHandle
		declare short SQLAllocEnv in odbc32 integer @env
		declare short SQLFreeEnv in odbc32 integer env
		
		* Do the base behavior.
		
		dodefault(tnMainKey)
		
	ENDPROC

	PROCEDURE isdriverinstalled		&& Determines if the specified driver is installed
		lparameter tcDriverName
		local laDrivers[1], ;
			lnDriver
		This.GetDrivers(@laDrivers)
		lnDriver = ascan(laDrivers, tcDriverName, -1, -1, 1, 15)
		return lnDriver > 0
		
	ENDPROC

	PROCEDURE removeuserdsn		&& Removes the specified user DSN
		lparameter tcDSN
		local llReturn, ;
			lcDriver, ;
			lcDSNString, ;
			lnSuccess
		do case
			case vartype(tcDSN) <> 'C' or empty(tcDSN)
				llReturn = .F.
			case This.DSNExists(tcDSN)
				lcDriver    = This.GetDataSourceProperty(tcDSN, 'Driver')
				lcDSNString = 'DSN=' + tcDSN + ccNULL + ccNULL
				lnSuccess   = SQLConfigDataSource(0, cnODBC_REMOVE_DSN, lcDriver, ;
					lcDSNString)
				llReturn    = lnSuccess > cnSUCCESS
				if not llReturn
					This.HandleODBCError()
				endif not llReturn
			otherwise
				llReturn = .F.
		endcase
		return llReturn
		
	ENDPROC

	PROCEDURE sqlconnect		&& Connects to the specified DSN
		*==============================================================================
		* Method:			SQLConnect
		* Status:			Public
		* Purpose:			Connects to the specified DSN
		* Author:			Doug Hennig
		* Copyright:		(c) 2016 Stonefield Software Inc.
		* Last Revision:	03/01/2016
		* Parameters:		tcDSN      - the DSN to connect to
		*					tcUserName - the user name to use
		*					tcPassword - the password to use
		* Returns:			.T. if the connection succeeded
		* Environment in:	none
		* Environment out:	This.nEnv and This.nConn contain handles needed by
		*						This.SQLDisconnect
		*==============================================================================
		
		lparameters tcDSN, ;
			tcUserName, ;
			tcPassword
		local lnEnv, ;
			lnConn, ;
			lnResult
		
		* Allocate the environment and connection handles.
		
		lnEnv  = 0
		lnConn = 0
		SQLAllocEnv(@lnEnv)
		if lnEnv = 0
			return .F.
		endif lnEnv = 0
		This.nEnv = lnEnv
		SQLAllocHandle(cnSQL_HANDLE_DBC, lnEnv, @lnConn)
		if lnConn = 0
			return .F.
		endif lnConn = 0
		This.nConn = lnConn
		 
		* Connect to the DSN.
		
		lnResult = SQLConn32(lnConn, tcDSN, len(tcDSN), ;
			tcUserName, len(tcUserName), tcPassword, len(tcPassword))
		return inlist(lnResult, cnSUCCESS, cnSQL_SUCCESS_WITH_INFO)
		
	ENDPROC

	PROCEDURE sqldisconnect		&& Disconnects from the DSN
		*==============================================================================
		* Method:			SQLDisconnect
		* Status:			Public
		* Purpose:			Disconnects from the DSN
		* Author:			Doug Hennig
		* Copyright:		(c) 2016 Stonefield Software Inc.
		* Last Revision:	03/01/2016
		* Parameters:		
		* Returns:			
		* Environment in:	
		* Environment out:	
		*==============================================================================
		
		SQLDisc32(This.nConn)
		SQLFreeHandle(cnSQL_HANDLE_DBC, This.nConn)
		SQLFreeEnv(This.nEnv)
		
	ENDPROC

ENDDEFINE
